<?xml version="1.0" encoding="UTF-8"?>

<document>

  <properties>
    <author email="mcconnell@dpml.net">Stephen McConnell</author>
    <title>DPML Metro Component Management Platform</title>
  </properties> 

  <body>

    <section name="DPML Metro">

      <p>
      Metro is an advanced component runtime solution.
      </p>
       
      <p>
      Metro is an <a href="ioc.html">IOC</a> Container  
      that handles the deployment of component-based applications. Beyond this Metro
      delivers pure framework independent component-driven <a href="ioc.html">Adaptive 
      Context</a> support backed by an <a href="management.html">Active State</a>, 
      model-driven, part-based system architecture. 
      </p>

      <subsection name="Model Driven">

        <p>
        Metro is a "Model Driven" system in that a central model is 
        the definiative source for runtime information.  Within Metro the complete
        deployment scenario including the component type internal datastructure
        is represented as a remotely accessible model.  Modification of the model 
        via local or remote invocations may have a direct impact on the application 
        deployment or runtime state.  Metro provides a suite of interfaces dealing 
        with remote control of of the component state machine, activation policy, 
        garbage collection policies, context state, and redepoloyment scenario 
        information (including control over component configuration, parameterization, 
        and individual context entry settings).
        </p>

      </subsection>

    <subsection name="Part Based">

      <p>
      As part of an overral risk-reduction strategy concerning product 
      evolution Metro incorporates an internal controller
      management model that enables concurrent execution of different 
      container versions within a single application.  This strategy
      enables changes that would normally be classed as breaking 
      compatibility to be isolated in dynamicaly loaded plugin control 
      subsystems.  The end-result is the potential for a composite 
      comoponent to operate seamlessly with components using radicaly 
      different controllers.
      </p>

      <p>
      This is achived through the combinaton of:
      </p>

      <ol>
        <li>Layered internal container APIs.</li>
        <li>Component deployment data tagged with supporting system version</li>
        <li>Dynamic loading of plugin controllers</li>
        <li>Controller delegation rules</li>
      </ol>

    </subsection>

      <subsection name="Related Links">
        <p><i>
        A broader overview of the issues and challenges related to component-based 
        development is presented in the paper 
        <a href="http://www.mrtc.mdh.se/publications/0953.pdf">Component-based 
        Development Process and Component Lifecycle</a> by Ivica Crnkovic, Stig Larsson, 
        Michel Chaudron.
        </i></p>
      </subsection>

    </section>

  </body>

</document>

