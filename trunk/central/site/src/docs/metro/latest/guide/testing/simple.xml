<?xml version="1.0"?>
<!--
 Copyright 2005 Niclas Hedhman.

 Licensed  under the  Apache License,  Version 2.0  (the "License");
 you may not use  this file  except in  compliance with the License.
 You may obtain a copy of the License at

   http://www.dpml.net/central/about/legal/

 Unless required by applicable law or agreed to in writing, software
 distributed  under the  License is distributed on an "AS IS" BASIS,
 WITHOUT  WARRANTIES OR CONDITIONS  OF ANY KIND, either  express  or
 implied.

 See the License for the specific language governing permissions and
 limitations under the License.
-->

<document>
  <properties>
    <author email="niclas@hedhman.org">Niclas Hedhman</author>
    <title>DPML Guide</title>
  </properties>

  <body>
    <section name="Simple Testing">
      <p>
        Simple testing is convinient when the entire Metro platform is not
        required, yet a component has some dependencies or other lifecycle
        artifacts that it needs. The test case is responsible to establish
        these instances and then pass it either through the injection type
        (constructor or methods) used by the component. Below is a brief
        description of how to establish each of the lifecycle instances that
        a component may require.
      </p>
      <subsection name="Logger" >
        <p>
          The <code>net.dpml.metro.unit.TestLogger</code> is an implementation
          of the <code>net.dpml.logging.Logger</code> interface, which will
          output everything to a provided <code>java.io.PrintStream</code>.
          The Level (DEBUG, ERROR and so on) that is enabled must also be
          provided through the constructor.
        </p>
<source><![CDATA[
import net.dpml.metro.unit.TestLogger;

public class MyComponentTest extends TestCase
{
    private MyComponent m_instanceUnderTest;

    public void setUp()
        throws Exception
    {
        TestLogger logger = new TestLogger( System.out, TestLogger.LEVEL_DEBUG );
        m_instanceUnderTest = new MyComponent( logger );
    }

    public MyComponentTest( String name )
    {
        super( name );
    }

    public void testSomeThing()
        throws Exception
    {
        //
    }
}
]]></source>
      </subsection>
      <subsection name="Parameters" >
        <p>
          The <code>net.dpml.metro.unit</code> provides a
          <code>TestParametersBuilder</code> class that has two static methods
          for creating a <code>net.dpml.parameters.Parameters</code> instance.
          One of the methods takes a <code>java.util.Map</code> as an argument
          and the other takes a <code>net.dpml.configuration.Configuration
          </code> argument. The latter is used when you need to create
          Parameters from XML files or XML inputstreams.
        </p>
<source><![CDATA[
import java.util.Properties;

import net.dpml.parameters.Parameters;

import net.dpml.metro.unit.TestLogger;
import net.dpml.metro.unit.TestParametersBuilder;

public class MyComponentTest extends TestCase
{
    private MyComponent m_instanceUnderTest;

    public void setUp()
        throws Exception
    {
        TestLogger logger = new TestLogger( System.out, TestLogger.LEVEL_DEBUG );
        Properties props = new Properties();
        props.put( "param1", "some value" );
        props.put( "param2", "some other value" );
        Parameters parameters = TestParametersBuilder.buildFromProperties( props );
        m_instanceUnderTest = new MyComponent( logger, parameters );
    }

    public MyComponentTest( String name )
    {
        super( name );
    }

    public void testSomeThing()
        throws Exception
    {
        //
    }
}
]]></source>
      </subsection>
      <subsection name="Configuration" >
        <p>
          Configurations are most commonly built from XML files or XML input
          streams of some sort. The <code>
          net.dpml.metro.unit.TestConfigurationBuilder</code> has a couple
          of methods for creation of <code>net.dpml.configuration.Configuration
          </code> instances. Currently, the builder extends from the
          default implementation package, and does not add any additional
          functionality, except providing an official testing API allowing
          for independent evolution of the implementation and unit testing
          packages.
        </p>
<source><![CDATA[
import net.dpml.configuration.Configuration;

import net.dpml.metro.unit.TestConfigurationBuilder;

import net.dpml.metro.unit.TestLogger;

public class MyComponentTest extends TestCase
{
    private MyComponent m_instanceUnderTest;

    public void setUp()
        throws Exception
    {
        TestLogger logger = new TestLogger( System.out, TestLogger.LEVEL_DEBUG );

        File confFile = new File( "some-config.xml" );
        TestConfigurationBuilder builder = new TestConfigurationBuilder();
        Configuration conf = builder.buildFromFile( confFile );
        m_instanceUnderTest = new MyComponent( logger, conf );
    }

    public MyComponentTest( String name )
    {
        super( name );
    }

    public void testSomeThing()
        throws Exception
    {
        //
    }
}
]]></source>
      </subsection>
      <subsection name="ServiceManager" >
        <p>
          In simple testing you need to manually wire any dependency, and
          provide that to each of the components via TestServiceManager
          instances. If the dependency chain is too large, this can become
          troublesome. It could be a sign that refactoring of the components
          are in order, or in case it is a matter of aggregation of many
          systems, then use <a href="integration.html">integration testing</a>
          method instead.
        </p>
<source><![CDATA[
import java.util.HashMap;

import net.dpml.metro.unit.TestLogger;
import net.dpml.metro.unit.TestServiceManager;

public class MyComponentTest extends TestCase
{
    private MyComponent m_instanceUnderTest;

    public void setUp()
        throws Exception
    {
        TestLogger logger = new TestLogger( System.out, TestLogger.LEVEL_DEBUG );
        MySuperDuper dep1 = new MySuperDuper( logger );
        dep1.initialize(); // Need to do the required lifecycle methods.
        dep1.start();

        MyHyperTyper dep2 = new MyHyperTyper( logger );

        HashMap deps = new HashMap();
        deps.put( "key-for-dep1", dep1 );
        deps.put( "key-for-dep2", dep2 );
        TestServiceManager manager = new TestServiceManager( deps );

        m_instanceUnderTest = new MyComponent( logger, manager );
    }

    public MyComponentTest( String name )
    {
        super( name );
    }

    public void testSomeThing()
        throws Exception
    {
        //
    }
}
]]></source>
      </subsection>
      <subsection name="Context" >
        <p>
          The Context created through the default constructor of
          <code>net.dpml.metro.unit.TestContext</code> will contain the
          standard context entries, and any additional entries can be provided
          in a Map for the other constructor. The standard context entries are
          set to;
        </p>
        <table>
          <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Value</th>
          </tr>
          <tr>
            <td>urn:metro:name</td>
            <td>java.lang.String</td>
            <td>unit-test</td>
          </tr>
          <tr>
            <td>urn:metro:partition</td>
            <td>java.lang.String</td>
            <td>/application/test</td>
          </tr>
          <tr>
            <td>urn:metro:dir</td>
            <td>java.io.File</td>
            <td>The target/test directory</td>
          </tr>
          <tr>
            <td>urn:metro:temp</td>
            <td>java.io.File</td>
            <td>A temporary directory named "target/test/$temp$"</td>
          </tr>
          <tr>
            <td>urn:metro:classloader</td>
            <td>java.lang.ClassLoader</td>
            <td>the classloader of the net.dpml.metro.unit.TestLogger</td>
          </tr>
        </table>
<source><![CDATA[
import net.dpml.metro.unit.TestContext;
import net.dpml.metro.unit.TestLogger;

public class MyComponentTest extends TestCase
{
    private MyComponent m_instanceUnderTest;

    public void setUp()
        throws Exception
    {
        TestLogger logger = new TestLogger( System.out, TestLogger.LEVEL_DEBUG );
        TestContext context = new TestContext();
        m_instanceUnderTest = new MyComponent( logger );
        m_instanceUnderTest.contextualize( context );
    }

    public MyComponentTest( String name )
    {
        super( name );
    }

    public void testSomeThing()
        throws Exception
    {
        //
    }
}
]]></source>
      </subsection>
    </section>
  </body>

</document>


